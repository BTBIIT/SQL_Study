-- 8장  카티션 곱
SELECT * FROM EMP; -- 14
SELECT * FROM DEPT; -- 4
SELECT * FROM EMP, DEPT; -- 56건

SELECT *
  FROM EMP, DEPT
ORDER BY EMPNO;

-- 8-2 동등 조인
SELECT *
  FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
ORDER BY EMPNO;

--8-3
SELECT E.EMPNO, E.ENAME, D.DEPTNO,  D.DNAME, D.LOC
  FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY D.DEPTNO, E.EMPNO;

SELECT *
FROM JOBS J, JOB_HISTORY H
WHERE J.JOB_ID = H.JOB_ID;

SELECT J.JOB_ID, J.JOB_TITLE, H.START_DATE,  H.END_DATE
FROM JOBS J, JOB_HISTORY H
WHERE J.JOB_ID = H.JOB_ID(+);

SELECT JOB_ID
            , MIN(START_DATE) START_DATE
            , MAX(END_DATE) MAX_DATE
  FROM JOB_HISTORY
GROUP BY JOB_ID;



SELECT J.JOB_ID, J.JOB_TITLE, H.START_DATE,  H.END_DATE
FROM JOBS J
                     , (SELECT JOB_ID
                            , MIN(START_DATE) START_DATE
                            , MAX(END_DATE) END_DATE
                            FROM JOB_HISTORY
                            GROUP BY JOB_ID) H
WHERE J.JOB_ID = H.JOB_ID(+);

SELECT COUNT (*) FROM JOBS;

SELECT * FROM EMPLOYEES;
--
SELECT E.EMPLOYEE_ID, E.LAST_NAME
            , D.DEPARTMENT_NAME
FROM  EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+);

SELECT *
  FROM LOCATIONS L;
  
SELECT *
  FROM LOCATIONS L , COUNTRIES C
WHERE L.COUNTRY_ID = C.COUNTRY_ID; -- 동등조인

SELECT * 
   FROM COUNTRIES;

-- 8-4 두 테이블에서 국가코드가 동일한뭐시기
SELECT COUNTRY_ID
  FROM LOCATIONS L , COUNTRIES C
WHERE L.COUNTRY_ID = C.COUNTRY_ID; --column ambiguously defined = > 어디에 있는 COUNTRY_ID 이니? 라는 뜻

SELECT L.COUNTRY_ID
            , C.COUNTRY_ID, C.COUNTRY_NAME
  FROM LOCATIONS L , COUNTRIES C
WHERE L.COUNTRY_ID = C.COUNTRY_ID; --column ambiguously defined = > 어디에 있는 COUNTRY_ID 이니? 라는 뜻

-- 8-5
SELECT EMPNO, ENAME, D.DEPTNO, DNAME, LOC
  FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY D.DEPTNO, E.EMPNO;

--8-6 급여가 3천 이상인 직원 정보와 부서 정보를 보고 싶은 경우
SELECT EMPNO, ENAME, D.DEPTNO, DNAME, LOC
  FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL >=3000;

-- 1분복습, EMP, DEPT 조인했을때
-- 급여가 2500 이하이고, 사원번호가 9999 이하인 정보를 출력
SELECT E.EMPNO, E.ENAME, E.SAL, E.DEPTNO
            , D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL <= 2500
AND E.EMPNO <= 9999
ORDER BY E.EMPNO;


-- 비등가 조인 : 등가 조인 이외의 방식
SELECT * FROM EMP;

-- 8-7 급여 범위를 지정하는 조건식으로 조인
SELECT * 
  FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

SELECT *
  FROM EMPLOYEES E, JOBS J
WHERE E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY;

SELECT *
  FROM EMPLOYEES E, JOB_HISTORY H
WHERE E.HIRE_DATE BETWEEN H.START_DATE AND H.END_DATE;

-- 자체 조인
SELECT * 
  FROM EMP E;
  
SELECT E.EMPNO, E.ENAME AS "사원명", M.ENAME AS "관리자명" 
  FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO;


SELECT E.EMPLOYEE_ID, E.FIRST_NAME || ' ' || E.LAST_NAME AS "사원명"
            , E.MANAGER_ID, M.FIRST_NAME || ' ' || M.LAST_NAME AS "관리자명"
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.MANAGER_ID = M.EMPLOYEE_ID;



-- 14 명 외부조인 직원 정보 위주 모두
SELECT E.EMPNO, E.ENAME AS "사원명", M.ENAME AS "관리자명" 
  FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO(+); -- LEFT OUTER JOIN 왼쪽에 기준으로 잡는것

SELECT * FROM EMP E;
-- 8-10
SELECT E.EMPNO, E.ENAME AS "사원명", M.ENAME AS "관리자명" 
  FROM EMP E, EMP M
WHERE E.MGR(+) = M.EMPNO; -- RIGHT OUTER JOIN 오른쪽에 기준으로 잡는것



-- COUNTRIES 테이블과 LOCATIONS 테이블을 COUNTRY_ID 기준으로 조인하여
-- COUNTRY_NAME, STATE_PROVINCE, STREET_ADDRESSF를 조회
SELECT *
  FROM COUNTRIES C, LOCATIONS L
WHERE C.COUNTRY_ID = L.COUNTRY_ID
ORDER BY C.COUNTRY_NAME, L.STATE_PROVINCE, L.STREET_ADDRESS;

-- JOBS 테이블과 JOB_HISTORY 테이블을 JOB_ID기준으로 조인하여
-- JOB_ID, JOB_TITLE, START_DATE, END_DATE를 조회
SELECT J.JOB_ID, J.JOB_TITLE, H.START_DATE, H.END_DATE
  FROM JOBS J, JOB_HISTORY H
WHERE J.JOB_ID = H.JOB_ID;

-- EMPLOYEES 테이블과 DEPARTEMENTS 테이블을 DEPARTMENT_ID 기준으로 조인하고
-- EMPLOYESS 테이블과 JOBS 테이블을 JOB_ID 기준으로 조인하여
-- FIRST_NAME, LAST_NAME, DEPARTMENT_NAME, JOB_TITLE을 조회
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME, E.JOB_TITLE
  FROM (SELECT EM.FIRST_NAME, EM.LAST_NAME, EM.DEPARTMENT_ID, J.JOB_ID, J.JOB_TITLE 
                FROM EMPLOYEES EM, JOBS J 
                WHERE EM.JOB_ID = J.JOB_ID) E
                        , DEPARTMENTS  D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;


-- COUNTRIES 테이블과 LOCATIONS 테이블을 LOCATIONS의 COUNTRY_ID를 기준으로 외부조인하여
-- COUNTRY_ID, COUNTRY_NAME, CITY를 조회
SELECT C.COUNTRY_ID, C.COUNTRY_NAME, L.CITY
  FROM COUNTRIES C, LOCATIONS L
WHERE C.COUNTRY_ID = L.COUNTRY_ID(+)
ORDER BY C.COUNTRY_ID;

-- EMPLOYEES 테이블과 DEPARTEMENTS 테이블을 DEPARTMENTS 테이블의 DEPARTMENT_ID
-- 기준으로 외부 조인하여 EMPLOYEE_ID, FIRST_NAME, LAST_NAME, DEPARTMENT_NAME을
-- EMPLOYEE_ID를 기준으로 정렬하여 조회
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME
  FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.EMPLOYEE_ID(+) = D.DEPARTMENT_ID
ORDER BY E.FIRST_NAME, D.DEPARTMENT_NAME;

-- EMPLOYEES 테이블을 MANAGER_ID와 EMPLOYEE_ID를 기준으로 자체 조인한 뒤
-- 직원의 FIRST_NAME과 LAST_NAME을 결합하고
-- 관리자의 FIRST_NAME 과 LAST_NAME을 결합하여
-- EMPLOYEE_ID를 기준으로 정렬하여 조회
SELECT E1.FIRST_NAME || ' ' || E1.LAST_NAME AS "직원이름"
            , E2.FIRST_NAME || ' ' || E2.LAST_NAME AS "관리자이름"
  FROM EMPLOYEES E1, EMPLOYEES E2
WHERE E1.EMPLOYEE_ID = E2.MANAGER_ID
ORDER BY E1.EMPLOYEE_ID;


-- SQL 99 
-- NATURAL JOIN : 등가 조인 대신
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE
            , E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
  FROM EMP E NATURAL JOIN DEPT D;       -- 등가 조인을 안써줘도 // 즉 WHERE 절에서 별도로 선언하지 않아도 사용이 됨

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE
            , E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
  FROM EMP E NATURAL JOIN DEPT D       -- 등가조인 처럼 써주면 오히려 에러가 남
ORDER BY DEPTNO, E.EMPNO;


-- JOIN ~ USING
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE
            , E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
  FROM EMP E JOIN DEPT D USING (DEPTNO)
WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO;
-- JOIN ~ ON 사용 시
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE
            , E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC
  FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO) -- 상위 SELECT쪽에서 받는 부분을 기존 처럼 명시해줘야 한다.
WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO;

-- 기존 방식으로 관리자 사원 명 (대표까지) 모두 출력할 때
SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME AS 관리자명
  FROM EMP E , EMP M
WHERE E.MGR = M.EMPNO(+);

-- 8-14 위 방식을 SQL-99 외부조인을 통해 나타낼 때
SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME AS 관리자명
  FROM EMP E LEFT OUTER JOIN EMP M ON (E.MGR = M.EMPNO); -- 14건
-- 만약 오른쪽 조인이면?
SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME AS 관리자명
  FROM EMP E RIGHT OUTER JOIN EMP M ON (E.MGR = M.EMPNO); -- 21건
-- 만약 FULL 조인이면?
  SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME AS 관리자명
  FROM EMP E FULL OUTER JOIN EMP M ON (E.MGR = M.EMPNO); -- 22건
  
  
SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME AS 관리자명 , D.DNAME
  FROM EMP E LEFT OUTER JOIN EMP M ON (E.MGR = M.EMPNO)
    JOIN  DEPT D ON (E.DEPTNO = D.DEPTNO);
    
    
    
    
-- 1분 복습
-- JOIN ~ USING         EMP, DEPT 조인 SQL 99 방식 DEPTNO
-- 급여는 3000 이상이며, 직속 상관이 반드시 있어야 합니다.
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM
            , D.DNAME, D.LOC
  FROM EMP E  JOIN DEPT D USING (DEPTNO)
WHERE E.SAL >= 3000 AND E.MGR IS NOT NULL
ORDER BY DEPTNO, E.EMPNO;

--239PAGE
-- 08-practice 01 번 SQL-99 방식 적용
SELECT E.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)   -- FROM 절에서 EMP와 DEPT를 선언 및 JOIN ON으로 동일 조건을 명시 및 묶음
WHERE SAL > 2000                                                                    -- WHERE 절에서 한 가지에 대해서만 필터링하면 적용이 가능
ORDER BY E.DEPTNO;

-- 08-practice 01번 SQL-99방식 미적용
SELECT E.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
  FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO                                             -- WHERE 절에서 DEPTNO가 같은 경우에 대해서 조건을 걸어줌
AND SAL > 2000                                                                        -- 이후 AND 조건을 통해 추가적인 조건을 걸어서 2000 달러 이상인 경우에만 출력
ORDER BY E.DEPTNO;

--08 practice 02번 SQL-99 방식 적용
SELECT E.DEPTNO, D.DNAME, ROUND(AVG(E.SAL),0) AS AVG_SAL
            , MAX(E.SAL) AS MAX_SAL
            , MIN(E.SAL) AS MIN_SAL
            , COUNT(*) AS CNT
  FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
GROUP BY E.DEPTNO, D.DNAME;
--SQL-99 방식(2)
SELECT DEPTNO,
       D.DNAME,
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       COUNT(*) AS CNT
  FROM EMP E JOIN DEPT D USING (DEPTNO)
GROUP BY DEPTNO, D.DNAME;
--08 practice 02번 SQL-99 방식 미적용 -- 복습 필요★★★
SELECT E.DEPTNO, D.DNAME, ROUND(AVG(E.SAL),0) AS AVG_SAL
            , MAX(E.SAL) AS MAX_SAL
            , MIN(E.SAL) AS MIN_SAL
            , COUNT(*) AS CNT
  FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
GROUP BY E.DEPTNO, D.DNAME;

--08 practice 03번 SQL-99 방식 적용 
-- 오른쪽 외부조인을 이용하는 방법으로 DEPT D에 맟춰야 하는 방법 따라서 RIGHT JOIN (기준 우측열)이 옴
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
  FROM EMP E RIGHT JOIN  DEPT D ON (E.DEPTNO = D.DEPTNO)
ORDER BY E.DEPTNO;

--08 practice 03번 SQL-99 방식 미적용 
-- 기존 SQL - 99가 아닌 방식으로 코딩할땐 맟춰야 되는 쪽에 +를 붙여줬음
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
  FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY E.DEPTNO;

--08-practice 04번 -- 복습 필요★★★
--SQL-99방식
SELECT D.DEPTNO, D.DNAME
          , E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO
          , S.LOSAL, S.HISAL, S.GRADE
          , E2.EMPNO AS MGR_EMPNO
          , E2.ENAME AS MGR_ENAME
  FROM EMP E RIGHT OUTER JOIN DEPT D 
                ON (E.DEPTNO = D.DEPTNO)                            -- 기준열은 DEPT 열로 우측정열하면서
              LEFT OUTER JOIN SALGRADE S                           -- 동시에 SALGRADE는 EMP에 왼쪽정렬로 맟춘다
                ON (E.SAL BETWEEN S.LOSAL AND S.HISAL)  -- E.SAL의 범위는 S,LOSAL ~ S.HISAL 사이 값
              LEFT OUTER JOIN EMP E2                                    -- 이후 똑같은 열을 호출하여  상관번호가 EMPNO 와 같은열만 호출
                ON (E.MGR = E2.EMPNO)                                  -- E.MGR (상관)이 E2.EMPNO(사원)와 같은 조건
ORDER BY D.DEPTNO, E.EMPNO;                                     -- 이후 DEPTNO와 EMPNO에 대하여 정렬

--SQL-99 이전 방식 -- 이 방식이 좀 더 가독성은 있는듯...
SELECT D.DEPTNO, D.DNAME,
       E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO,
       S.LOSAL, S.HISAL, S.GRADE,
       E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
  FROM EMP E, DEPT D, SALGRADE S, EMP E2                 -- 4가지를 조인함
WHERE E.DEPTNO(+) = D.DEPTNO                                     -- E.DEPTNO를 D.DEPTNO에 맟춤
     AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)       -- 그리고 E.SAL의 범위는 S.LOSAL과 S.HISAL 사이 임
     AND E.MGR = E2.EMPNO(+)                                           -- 그리고 E,MGR = E2.EMPNO임
ORDER BY D.DEPTNO, E.EMPNO;                                       -- 이렇게 된 테이블을 D.DEPTNO와 E.EMPNO에 대해 정렬함

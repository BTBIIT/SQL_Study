-- chapter 14 제약조건
-- 무결성			:	데이터의 정확성과 일관성을 보장한다는 의미
-- 제약조건		:	무결성을 지키기 위한 안전장치
/*

영역 무결성 (DOMAIN INTEGRITY)				:
	- 저장 값의 적정여부확인, 적절한 형식,	NULL 여부 같은 정해 놓은 범위

개체 무결성 (ENTITY INTEGRITY)					:
	- 데이터를 유일하게 식별할 수 있는 값을 가지고 있어야 하고 NULL 값이 될 수 없고 중복 불가

참조 무결성 (REFERENTIAL	INTEGRITY)	:
	- 참조 테이블을 기본키로 존재해야하며 NULL 가능

*/

-- 14 - 1
CREATE TABLE TABLE_NOTNULL
(
				LOGIN_ID 		VARCHAR2(20) NOT NULL,
				LOGIN_PWD 	VARCHAR2(20) NOT NULL,
				TEL					VARCHAR2(20) 
);

DESC TABLE_NOTNULL;

INSERT INTO TABLE_NOTNULL (LOGIN_ID,	LOGIN_PWD,	TEL)
VALUES ('TEST_ID_01', NULL,	'010-1234-5678');						-- TABLE에 NOT NULL 설정으로 인해서 에러가 남 cannot insert NULL into

INSERT INTO TABLE_NOTNULL (LOGIN_ID,	LOGIN_PWD)
VALUES ('TEST_ID_01', 1234);						

SELECT * FROM TABLE_NOTNULL;

-- 14-4
UPDATE TABLE_NOTNULL
	SET		LOGIN_PWD = NULL
WHERE	LOGIN_ID = 'TEST_ID_01';					-- 설정 자체가 NOT NULL이라 마찬가지로 CANNOT UPDATE 오류가 남


SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM	USER_CONSTRAINTS
WHERE TABLE_NAME = 'TABLE_NOTNULL';
-- CONSTRAINT_TYPE	:
-- C	: 	CHECK, NOT NULL
-- U	:	UNIQUE
-- P	:	PRIMARY	KEY
-- R	:	FOREIGN	KEY

CREATE TABLE TABLE_NOTNULL2
(
	LOGIN_ID		VARCHAR2(20)	CONSTRAINT	TBLNN2_LGNID_NN	NOT	 NULL,
	LOGIN_PWD	VARCHAR2(20) CONSTRAINT	TBLNN2_LGNPW_NN NOT NULL,
	TEL					VARCHAR2(20)
);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM	USER_CONSTRAINTS
WHERE TABLE_NAME = 'TABLE_NOTNULL2';


--
SELECT * FROM TABLE_NOTNULL;

ALTER TABLE TABLE_NOTNULL
	MODIFY 
	(
	TEL NOT NULL
	); -- null values found 02296. 00000 - "cannot enable (%s.%s) - null values found"		-- NULL인 항목이 있어서 안됨
	
UPDATE TABLE_NOTNULL
	SET TEL = '010-1234-5678'
WHERE	LOGIN_ID	= 'TEST_ID_01';

SELECT * FROM TABLE_NOTNULL;

ALTER TABLE TABLE_NOTNULL
	MODIFY 
	(
	TEL NOT NULL
	);						-- TEL 항목이 NULL이 사라져서 업데이트 가능
	
-- 
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TABLE_NOTNULL2';
-- 중요
ALTER TABLE TABLE_NOTNULL2
	MODIFY (TEL CONSTRAINT TBLNN2_TELNN NOT NULL);	
DESC TABLE_NOTNULL2;


-- 이미 생성된 제약 조건 이름 변경하기
-- 14 -12 PAGE 368
ALTER TABLE TABLE_NOTNULL2
RENAME CONSTRAINT TBLNN2_TELNN TO TBL2_TEL_NN;

ALTER TABLE TABLE_NOTNULL2
DROP CONSTRAINT TBL2_TEL_NN;

DESC TABLE_NOTNULL2;

-- NOT NULL
-- UNIQUE
-- PRIMARY KEY
-- FOREIGN KEY
-- CHECK
-- DEFAULT

CREATE TABLE TABLE_UNIQUE
(
	LOGIN_ID		VARCHAR2(20) UNIQUE,
	LOGIN_PWD	VARCHAR2(20) NOT NULL,
	TEL					VARCHAR2(20)
);


DESC TABLE_UNIQUE;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TABLE_UNIQUE';

INSERT INTO TABLE_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('TEST_ID_01', 'PWD01', '010-1234-5678');
SELECT * FROM TABLE_UNIQUE;

INSERT INTO TABLE_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('TEST_ID_02', 'PWD01', '010-1234-5678');
SELECT * FROM TABLE_UNIQUE;
COMMIT;


INSERT INTO TABLE_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL)
VALUES (NULL, 'PWD01', '010-1234-5678');		-- UNIQUE는 널값 허용
SELECT * FROM TABLE_UNIQUE;

-- 
SELECT *
	FROM TABLE_UNIQUE
WHERE LOGIN_ID IS NULL;
-- 14-20	-- UPDATE가 막혀있음 		-- 왜냐면 동일 한 아이디는 생성 불가하게 만들었기 때문에
UPDATE TABLE_UNIQUE
	SET LOGIN_ID = 'TEST_ID_01'
WHERE LOGIN_ID IS NULL;

CREATE TABLE TABLE_UNIQUE2
(
		LOGIN_ID		VARCHAR2(20)	CONSTRAINT TBLUNQ2_LGNID_UNQ UNIQUE,
		LOGIN_PWD	VARCHAR2(20)	CONSTRAINT TBLUNQ2_LGNPW_NN NOT NULL,
		TEL					VARCHAR2(20)
);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

SELECT * FROM TABLE_UNIQUE;

ALTER TABLE TABLE_UNIQUE	-- 중복키가 있으면 유니크 변경이 안됨 -- NULL은 중복이 허용됨
MODIFY (TEL UNIQUE);

UPDATE TABLE_UNIQUE
	SET TEL = NULL;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

SELECT * FROM TABLE_UNIQUE2;

-- UNIQUE로 업데이트 할 때
ALTER TABLE TABLE_UNIQUE2
MODIFY (TEL CONSTRAINT TBLUNQ_TEL_UNQ UNIQUE);


SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

ALTER TABLE TABLE_UNIQUE2
RENAME CONSTRAINT TBLUNQ_TEL_UNQ TO TBLUNQ2_TEL_UNQ;	-- 변경 시 CONSTRAINT


ALTER TABLE TABLE_UNIQUE2
DROP CONSTRAINT TBLUNQ2_TEL_UNQ;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

-- PRIMARY KEY		:		NOT NULL + UNIQUE
-- NULL, 중복 허용 x
CREATE TABLE TABLE_PK
(
		LOGIN_ID			VARCHAR2(20)	PRIMARY KEY,
		LOGIN_PWD		VARCHAR2(20) NOT NULL,
		TEL						VARCHAR2(20)
);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_PK%';

CREATE TABLE TABLE_PK2
(
		LOGIN_ID			VARCHAR2(20)	PRIMARY KEY,
		LOGIN_PWD		VARCHAR2(20) NOT NULL,
		TEL						VARCHAR2(20)

);

INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('TEST_ID_01', 'PWD01', '010-1234-5678');

INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('TEST_ID_01', 'PWD02', '010-2345-6789'); -- 중복 불가

INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES (NULL, 'PWD02', '010-2345-6789'); -- NULL 불가

CREATE TABLE TABLE_NAME(
	COL1 VARCHAR2(20),
	COL2 VARCHAR2(20),
	COL2 VARCHAR2(20),
	PRIMARY KEY(COL1),
	CONSTRAINT CONSTRAINT_NAME UNIQUE(COL2)
);


-- EMP 테이블과 DEPT 테이블의 제약 조건
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
			, R_OWNER,	R_CONSTRAINT_NAME
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('EMP','DEPT');

INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (9999, '홍길동', 'CLERK', 7788, '2024-06-13', 1200, NULL, 99); --parent key not found -- PK_DEPT 가 설정되어 있음 EMP에서 참조하는 키 FK_DNO 확인 CREATE TABLE EMP ~ 부분확인

CREATE TABLE DEPT_FK(
		DEPTNO	NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY,
		DNAME	VARCHAR2(14),
		LOC			VARCHAR2(13)
);

CREATE TABLE EMP_PK	(
	EMPNO 		NUMBER(4)	CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
	ENAME		VARCHAR2(10),
	JOB				VARCHAR2(9),
	MGR			NUMBER(4),
	HIREDATE	DATE,
	SAL				NUMBER(7,2),
	COMM		NUMBER(7,2),
	DEPTNO		NUMBER(2)	CONSTRAINT EMPFK_DEPTNO_FK	REFERENCES DEPT_FK (DEPTNO)
);


SELECT * FROM DEPT_FK;

INSERT INTO EMP_PK
VALUES (9999, 'TEST_NAME', 'TEST_JOB', NULL, '2001/01/01', 3000, NULL, 10); -- ERROR

INSERT INTO DEPT_FK
VALUES (10, 'TEST_DNAME', 'TEST_DEPTNO');

INSERT INTO EMP_PK
VALUES (9999, 'TEST_NAME', 'TEST_JOB', NULL, '2001/01/01', 3000, NULL, 10); -- SUCCESS

COMMIT;

DELETE FROM DEPT_FK
	WHERE DEPTNO = 10;	-- FK가 있어서 삭제가 안됨 - child record found
	
-- CHECK	:	입력 값의 범위 패턴을 정의할 때 사용

CREATE TABLE TABLE_CHECK(
			LOGIN_ID		VARCHAR2(20)	CONSTRAINT TBLCK_LOGIND_PK PRIMARY KEY,
			LOGIN_PWD	VARCHAR2(20)	CONSTRAINT	TBLCK_LOGINPWD_CK	CHECK (LENGTH (LOGIN_PWD) > 3 ),
			TEL					VARCHAR2(20)
);

INSERT INTO TABLE_CHECK
VALUES ('TEST_ID', '123', '010-1234-5678');		-- ERROR

INSERT INTO TABLE_CHECK
VALUES ('TEST_ID', '1234', '010-1234-5678');		-- SUCCESS

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_CHECK';

-- 14-7 기본값을 정하는 DEFAULT
CREATE TABLE TABLE_DEFAULT
(
	LOGIN_ID		VARCHAR2(20)	CONSTRAINT	TBLCK2_LGNID_PK PRIMARY KEY,
	LOGIN_PWD	VARCHAR2(20) DEFAULT '1234',
	TEL					VARCHAR2(20)
);

INSERT INTO TABLE_DEFAULT
VALUES ('TEST_ID', NULL, '010-1234-5678');

INSERT INTO TABLE_DEFAULT (LOGIN_ID, TEL)
VALUES ('TEST_ID2', '010-1234-5678');

SELECT * FROM TABLE_DEFAULT;



-- 14 Q1
-- DEPT_CONST 테이블과 EMP_CONST 테이블을 다음과 같은 특성 및 제약 조건을 지정하여 만들어 보세요
CREATE TABLE DEPT_CONST
(
	DEPTNO NUMBER(2)	CONSTRAINT DEPTCONST_DEPTNO_PK PRIMARY KEY,
	DNEMA	VARCHAR2(14) CONSTRAINT DEPTCONST_DNAME_UNQ UNIQUE,
	LOC			VARCHAR2(13)	CONSTRAINT DEPTCONST_LOC_NN NOT NULL
);

-- EMP_CONST 테이블
CREATE TABLE EMP_CONST
(
	EMPNO 		NUMBER(4)		CONSTRAINT EMPCONST_EMPNO_PK PRIMARY KEY,
	ENAME 		VARCHAR2(10) CONSTRAINT EMPCONST_ENAME_NN NOT NULL,
	JOB				VARCHAR2(9),
	TEL				VARCHAR2(20)	CONSTRAINT EMPCONST_TEL_UNQ UNIQUE,
	HIREDATE	DATE,
	SAL				NUMBER(7,2)	CONSTRAINT EMPCONST_SAL_CHK	CHECK(SAL BETWEEN 1000 AND 9999),
	COMM		NUMBER(7,2),
	DEPTNO		NUMBER(2)		CONSTRAINT EMPCONST_DEPTNO_FK REFERENCES DEPT_CONST(DEPTNO)
);

-- 확인
SELECT OWNER, TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE '%_CONST'
ORDER BY CONSTRAINT+_NAME;









